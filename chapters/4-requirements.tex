\chapter{Requirements}
\label{cha:middleware}
The Solid project aims to solve the problem of decentralizing the web by giving data back to the user. However, no distinction is made between the trust level given to client applications. \middleware{} tries to mitigate this by providing an additional software layer in between the client and Solid server, which provides more fine-grained privacy control options. This problem statement determines the general goals of \middleware{}, but in order to guide the design effectively, some concrete requirements are needed, both non-functional, functional, and from a privacy-perspective. To come up with adequate requirements, we guide the process by making use of two concrete example use-cases, specified in section \ref{sec:usecases}.   \todo{Needs more detailed description}

\section{Use cases}
\label{sec:usecases}
\todo[inline]{Should these be more detailed? No real step-by-step description, maybe include this?"}
\subsection{Exercise}
The anonymization of data including health-related attributes makes a very good use-case to guide the design and development of \middleware{}, since those attributes are sensitive personal information. In this use-case, exercise data from an application such as Strava is stored on the user's Solid pod. He wishes to export this data to a ranking board application to see who of his friends runs the fastest. However, he does not wish to share his exact heart rate since this is sensitive data. Since no suitable linked-data format for running exercises was found (i.e., one that supports all the necessary fields such as heart rate), the \gls{TCX} file format\footnote{Schema: \url{https://www8.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd}} is used instead. An additional advantage of this format is that it is supported by popular tools such as Strava and can be imported/exported by exercise trackers such as Garmin devices. Unfortunately, this is not a linked-data format, which is a bit contrary to the Solid philosophy. However, it is perfectly supported by solid, and it is a well-known and open format. Since using a non-linked data format has no real repercussions on the validity of the use-case or the developed proof-of-concept, this is seen as a necessary trade-off. \todo{Correctly worded?}.

\subsection{Personal finance}
In this use case, the user has stored all his transactions on his Solid pod, and he wishes to see some trends and statistics about his spendings. An example of such a statistic is "how much do I spend on groceries every week?".  However, expenses are very sensitive data, especially when these are exact numbers and store locations. Therefore, the user opts to use \middleware{} to filter out the most sensitive information yet still receive relevant statistics. This is done by removing direct identifiers, and aggregating indirect identifiers, such as store locations and exact spendings at individual transactions.  For example, for entries of the type "Alice spent \texteuro 5,82 at Colruyt Leuven on 8/11/2021 16:53", the user wishes to modify this into something similar to "User87532 spent \texteuro 5 at Supermarket on 8/11/2021". This way, trends in the spending are kept (by rounding exact amounts to nearby integers, and replacing exact stores with store types). Information such as "you spent \texteuro 400 in supermarkets this month" will still be available (and relatively accurate), without giving away exact details. An example personal finance app, running on Solid, is \href{https://github.com/solid/money-pane}{money-pane}. Like in the last use-case, unfortunately no suitable linked-data format was found, and a proprietary data format must be used. 
However, the usage of linked-data formats does not have any influences on the developed architecture, and have no influence of the developed proof-of-concept, since the developed architecture is independent of the chosen content representation.

\section{Functional requirements}
Since \middleware{} builds forth upon the Solid project, it is crucial that it follows the same philosophy. A core property of Solid is its \textbf{decentralization}, implying that anyone can run a Solid server and host their pod themselves. Since other users may prefer to use a pod from a provider such as Inrupt\footnote{\url{https://inrupt.com}}, \middleware{} must be able to be run stand-alone. This ensures that everyone can run \middleware{} and users are not stuck using the same provider for both their pod and \middleware{}. This comes at a certain performance cost (twice the number of HTTP requests instead of treating the data locally at the Solid server, among a number of other performance inhibitors). However, since decentralization is such a core concept of Solid, this is a necessary trade-off. To counter this, extra attention must be paid to make \middleware{} as performant as possible. Adapting \middleware{} to be included in a Solid server may be an interesting future research path. \todo{juist verwoorden dat ik geloof dat het een sacrifice is die het waard is om te maken, maar dat ander onderzoek mogelijk is om een gelijkaardig concept binnen de bestaande community server te bouwen}

Solid builds further upon the principles of Linked Data, and Solid servers can store any type of data. As \middleware{} aims to be a general solution, it should work in every case where a Solid server following the specification works\footnote{At least, when reading resources.}. This also implies that it must provide a way to anonymize \textit{any} type of data textually represented data. Thus, \textbf{flexibility for the supported data scheme} is an essential part of \middleware{}. Concretely, \middleware{}'s core should not hard-code any supported data schemes and which PET should be applied to them: these should be able to be plugged in flexibly and selected automatically, to ensure that any data scheme can be supported. This provides a technical challenge, as a sufficient level of abstraction must be developed to be able to support any data scheme, while ensuring that the leakage requirements are not violated.

Different client applications may be trusted differently, just as that different data schemes may contain more or less sensitive data elements. An important aspect to solve is thus being able to distinguish different \textit{privacy levels}: required levels of anonymization. \middleware{} must therefore not only be able to adapt to different data schemes, but must also support different privacy levels for every data scheme. The selected PET is highly dependent on the data scheme\todo{explain why, ie sometimes better to delete data, other times pseudonym, or generalise} and required level of privacy, therefore \middleware{} must \textbf{automatically select \gls{PETs}} based on the input data scheme and requested privacy level.

Finally, the Solid project is still very much a work in progress. This implies that the specification will likely be modified many times in the future, and additional features will be added. If \middleware{} wants to successfully keep interacting with Solid servers, the architecture should be \textbf{ready to easily be extended} in order to support newly released features and modifications. 

\section{Non-functional requirements}
Solid aims to become the de facto standard for web applications in the future. Consequently, it must be intuitive for non-technical users. There can be no technical jargon, and it must be incredibly easy to set-up. Since \middleware{} aims to follow this philosophy, the proposed solution must be \textbf{intuitive to use} for non-technical users. Concretely, this means that it should be opaque to the users which concrete PET is applied for which use case. On that account, a number of \textit{privacy levels} should be created and presented to the user in a simple manner: a higher privacy level means more data protection but less utility. The user will then be able to select between a number of privacy levels, without needing to understand the technical details behind the scenes. Examples of concrete transformations can be given, to make the effects of selecting a certain level more comprehensible. Section \ref{sec:privacylevels} introduces four privacy levels that are used in the developed proof-of-concept, but these serve only as a concrete example. 

Since \middleware{} should be able to be run stand-alone, the software will act as a \textit{proxy} through which the traffic between the Solid application and server flows. This comes at a large performance cost, as for example the number of HTTP requests is doubled, the data must be parsed in both \middleware{} and the application, etc. Bad performance can turn users away from using \middleware{}, so special attention must be paid to ensure that the \textbf{performance} does not worsen to the point that requests time out or that applications become unusable. Specifically, \textit{latency} between the the request coming out of the Solid application and the response it receives should be minimized.

Since \middleware{} operates so dynamically, there is a lot of opportunity for bugs to sneak in that will go unnoticed. Some bugs may only appear under the presence of a specific combination of transformations in the configuration files. Therefore, \textbf{testability} is an important aspect. Increased testability gives stronger guarantees of the correct behavior of \middleware{}, which is essential in the context of a privacy-enhancing technology.  

\section{Adversary model}
\todo[inline]{Write here a paragraph about the considered adversary model, decide what leakage is allowed, maybe introduce concept of privacy levels here, ...}
\begin{itemize}
    \item Focus on honest-but-curious attacker or active attacker?
    \item Transport uses https, so this is out of scope
    \item Pay special attention to data while it resides in \middleware{}; here it is untreated and maybe several users use the software at the same time. Since this untreated data contains a lot of personal information, important that there is no potential leakage to other processes etc. 
    \item Also discuss here that \middleware{} focuses on preventing (or lowering the risks of) attribute disclore, and not identity disclosure!
    \item And finally, discuss the trust model: we trust the Solid server, but the application is less trusted, and there are gradations/different levels in the trust given to applications
\end{itemize}

\section{Privacy levels}
\label{sec:privacylevels}
\todo[inline]{Explain: different users may want different levels of granularity and experts in the field may be able to more rigorously define such levels. Therefore, the supported number of levels must be dynamic as well.}
\todo[inline]{see feedback Dimitri, better to define these in terms of maximum allowed leakage.
Also talk about privacy-utility trade-off, and how these privacy levels make the middleware more context-sensitive }
In order to provide an intuitive mechanism for selecting which data is transformed, different privacy levels are introduced. These privacy levels form an abstraction above the concrete data transformations and \gls{PETs} that are applied to the data before it is passed on to the application. This ensures that non-technical users can use \middleware{}, without needing to know the technical details of the technologies and tactics that are employed. Four levels of increasing privacy are proposed, based partially on the \gls{GDPR} definition of sensitive personal data and on the types of identifiers defined in section \ref{sec:data-deid}.\\

\noindent \textbf{Level 1: all data} No data transformations are applied, all data is passed to the requesting application.\\

\noindent \textbf{Level 2: Removal of sensitive personal data} Sensitive personal data, as defined by the GDPR \citep{gdpr}, is removed from the dataset. This includes data consisting of racial or ethnic origin, political opinions, religious or philosophical beliefs, or trade union membership, genetic data, biometric data, data concerning health, data concerning criminal convictions or data concerning a natural person's sex life or sexual orientation. Thus, the tactic \textit{Remove} is applied to all data elements matching this definition.\todo{Explain why remove is the best tactic here}\\

\noindent \textbf{Level 3: Pseudonymization/generalisation of direct identifiers} Since level 3 is a stronger version of level 2, sensitive personal data is removed first. Additionally, direct personal identifiers are pseudonymized or generalized. Concretely, the tactics \textit{Pseudonym}, \textit{Placeholder}, \textit{Aggregate} and \textit{Blur} may be applied here, depending on the specific data attribute. In addition, data elements may also be \textit{perturbed}. Examples are the replacement of names by placeholders, the perturbation or adding a placeholder for birth dates (such that the exact date is obscured, but the age is still correct), the removal of street names and numbers while keeping larger geographic areas such as cities, etc. This makes the data still relatively accurate, while direct identification of the user is made impossible.\\

\noindent \textbf{Level 4: Pseudonymization/generalisation of (in)direct identifiers} In addition to direct identifiers, also indirect identifiers are now modified or removed. The same \gls{PETs} and tactics are used, but are now applied more strictly and to more data attributes. For example, when perturbing birth dates, now the exact age is not kept exactly, but it is changed to a range within the exact age. Cities may also be perturbed when possible, but keeping for example the province or state. Other indirect identifiers such as genders may also be modified or removed.

\todo[inline]{Maybe a custom level should also be supported for specific format, where the user can say that if the datatype is x, I want to apply transformation y to field z.}